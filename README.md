# Задание 1

Описание: Представьте, что в языке Python пропали встроенные словари (dict), и вам нужно создать собственный класс MyDict, который будет вести себя подобно словарю. Класс MyDict должен поддерживать следующие операции:


__init__(): Инициализация пустого словаря.
  
__getitem__(key): Получение значения по ключу. Если ключ не существует, вернуть None.

__setitem__(key, value): Установка значения по ключу.

__delitem__(key): Удаление элемента по ключу. Если ключ не существует, ничего не делать.

keys(): Возвращение списка всех ключей в словаре.

values(): Возвращение списка всех значений в словаре.

items(): Возвращение списка пар (ключ, значение) в словаре.

__str__(): Возврат строкового представления словаря для удобства отладки.


Пример использования:
```python
my_dict = MyDict()
my_dict['name'] = 'Alice'
my_dict['age'] = 30
print(my_dict['name'])  # Вернет 'Alice'
print('city' in my_dict)  # Вернет False
del my_dict['age']
print(my_dict.keys())  # Вернет ['name']
print(my_dict.values())  # Вернет ['Alice']
```

Задача:
Напишите класс MyDict, который реализует указанные операции. Ваш класс должен обеспечивать аналогичное поведение, как у встроенных словарей в Python.

# Решение 1

Класс находится в папке [dict_task](dict_task).

### Тестирование

Для проверки решения используется **doctest** с активным параметром **verbose**. Тест-кейсы распределены по соответствующим методам. Запуск тестов:

```bash
python -m dict_task.my_dict
```

### Архитектура

Значения ключей-значений хранятся в списке списков **_hash_space**.

Первое измерение в **_hash_space** для остатка от деления хешей ключей на размер **_hash_space** (по умолчанию 1028). Что частично воспроизводит идею реализации [Python словаря на С](https://github.com/python/cpython/blob/main/Objects/dictobject.c). С применением устаревшего подхода через разреженное хранение значений (описано [Реймондом Хеттингером](https://mail.python.org/pipermail/python-dev/2012-December/123028.html) в письме о новом подходе).

Отдельный сет контролирует, какие индексы **_hash_space** заняты значениями - упрощает работу с публичными методами.

Второе измерение **_hash_space** хранит список ключей-значений в порядке добавления.

Для поиска значений во втором измерении **_hash_space** используется бинарный поиск.

Данный подход позволяет в среднем иметь следующие показатели сложности операций:

|        **операция**         | **сложность** |                                                         **комментарий**                                                          |
|:---------------------------:|:-------------:|:--------------------------------------------------------------------------------------------------------------------------------:|
|           вставка           |   O(log 2n)   | Получение хеша, чтение из списка по индексу - все операции выполняются за константное время. Вставка с помощью бинарного поиска. |
|  чтение - ключ отсутствует  |     O(1)      |                                               Проверка существования через **set**                                               |
|     чтение - ключ есть      |   O(log 2n)   |                          Как и вставка, но бинарный поиск ищет не индекс для вставки, а само значение.                           |
| удаление - ключ отсутствует |     O(1)      |                                               Проверка существования через **set**                                               |
|    удаление - ключ есть     |   O(log 2n)   |                       К операциям за константное время добавляется поиск индекса в отсортированном списка                        |

Работа с параметром **_order_index** позволяет реализовать сохранение порядка значений согласно порядку вставки. Если отказаться от этой фичи - вставку новых значений можно будет проводить за константное время.

Публичные методы **keys, values & items** под капотом обращаются к методу **_get_all_items_sorted**, который отвечает за получение списка именованый кортежей, отсортированного по порядку вставки значений. Работу публичных методов можно ускорить, если с помощью генераторов отказаться от одного из промежуточных списков.

### Комментарий

Использовал сеты, так как задание не уточняет, что все реализации хеш-таблиц под запретом.

Небольшую гонку за производительностью попробовал, потому что было интересно. Но переписывать современный С код словаря не стал из соображений баланса результат-время. И из соображений спортивной честности.

# Задание 2

Студентам была дана задача: Определить, как часто встречается определенная буква в строке. Напишите функцию, которая будет принимать строку, а возвращать словарь с частотой каждого символа.

В файле student_task.py находится решение этой задачи одним из студентов. Какой комментарий вы напишете этому студенту? Ответ не должен содержать верное на ваш взгляд решение задачи, а только замечания и рекомендации, которые помогут студенту. 

# Решение 2

Связанные с заданием файлы перенесены в папку [review_task](review_task).

Само ревью на работу студента находится в файле [review.md](review_task/review.md).

Применена политика сбалансированной похвалы и перечисление пунктов для улучшения с целью стимулирования интереса к занятиям. Ревью избегает прямых ответов с целью стимулирования технического мышления.
