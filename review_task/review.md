# Ревью задания

Привет! Ниже ты найдешь разбор твоего домашнего задания. В целом **очень сильная работа**! Если вкратце - у тебя отличная функциональность, по этому критерию добавить особо нечего! Есть что улучшить по производительности. Над читаемостью имеет смысл поработать.

### Текст самого задания

Определить, как часто встречается определенная буква в строке. Напишите функцию, которая будет принимать строку, а возвращать словарь с частотой каждого символа.

### Что получилось хорошо

- Решение полностью рабочее и делает ровно то, что надо!
- Код написан с уважением к линтерам - **PyCharm** не видит ни одной проблемы в файле!
- Грамотно выбраны типы переменных. Словарная структура идеально подходит для этой задачи!
- Круто, что даже попробовал сделать усложнённую часть задания! В базовой версии задания было достаточно вывести буквы количественно, а ты проявил живой интерес и поэкспериментировал за рамками программы. 
- Двумя функциями ты показал умение грамотно структурировать свой код - каждая функция имеет свою конкретную и понятную ответственность. Прямо по учебнику!
- Знаешь о коллизии имён и ловко придумал как её обойти через **str_**!
- Здорово, что соблюдаешь принципы именования функций! Начинать имена функций с глагола - то что надо!
- Радует, что каждая строка кода - максимально лаконична. Обычно начинающие разработчики пишут много кода и операций на одну строку. Чем избыточно переусложняют свой код.
- Хорошо, что тестируешь свой код! Позже мы пройдём библиотеки и методы тестирования углублённо. Но боевой дух тестировщика у тебя уже есть!
- Хорошие комментарии к принтам!

### Что можно улучшить

#### Читаемость

Большую часть времени программист не столько пишет, сколько читает код. Свой и своих коллег. Очень важно, чтобы код было легко и удобно читать, понимать его. Улучшив следующие моменты - ты сделаешь свои работы более профессиональными:

- Приём с нижним подчеркиванием для аргумента **str_** классный, но ещё лучше **избегать похожих имён** полностью. Как думаешь, какое простое и короткое слово отразит то, как ты используешь эту переменную?
- У тебя есть часть переменных, имена которых слабо отражают то, как они используются. Кроме уже попавшего в фокус нашего внимания **str_** то же можно сказать про **dictionary**. Сейчас имя описывает тип данных, но не **смысл и задачу самой переменной**. Подумай, какой ценностью обладают данные внутри этой переменной? Какое название больше подойдёт? Например, **letters** было бы лучше переименовать в **lowercase_text**. Просто **letters** - не совсем понятно, там все разные буквы всех алфавитов, могут ли там быть заглавные... Чем меньше вопросов вызывает переменная - тем лушче. Также стоит подумать над переменными **count**, **summary**, **key**.
- **Следует избегать сокращения имён** переменных. Это сейчас в момент написания легко помнить кто такие **cor** & **str_**, от каких слов образованы. Но чем больше времени пройдёт - тем сложнее будет понимать собственный код. Лучше разворачивать имена полностью. Однажды в сложном коде коллеги я встретил имя **val** и совсем не сразу понял, сокращением от чего оно является: value, values, valid, validity... 
- **Использование i** имеет свои особенности. Да, это сокращение, которое следует избегать. Однако благодаря влиянию математиков - это имя переменной вошло в моду для перебора индексов, в крайнем случае чисел. Но у тебя ни одна из этих ситуаций не подходит. Подумай - что именно ты перебираешь этой переменной?
- Имя **get_count_char** сейчас может вводить в заблуждение. Два идущих подряд глагола затрудняют понимание, что же всё-таки должно происходить. Что мы получаем? Count char? В анлийском это предложение посчитать буквы. Больше подойдёт что-то про результат функции. Попробуй один глагол убрать. Слово **char** - это про любой символ. Но ты ведь считаешь не все символы подряд? Цифры тоже символы, знаки препинания.
- Имя **get_percent_correlation** тоже не совсем точное. Тут слово **get** выглядит лучше, чем в первой функции. Но что именно мы получаем? Корреляция - это мера взаимности некоторой связи. Долю каждой буквы от общего количества лучше назвать по-другому.
- Чем меньше вложенностей в коде - тем легче с ним работать. Один из приёмов для уменьшения вложенности - [Guard Block](https://www.kaggle.com/discussions/general/485872). Подумай, где в твоём коде этот приём прям напрашивается?
- Многострочный текст открывать и закрывать нужно на одинаковом уровне вложенности. Сейчас у тебя при закрытии избыточный отступ.

Рекомендую ознакомиться с [правилами именования в PEP8](https://peps.python.org/pep-0008/#naming-conventions).

#### Производительность

Хороший код не только легко читается, но и по возможности не делает ничего лишнего. В приложениях большое количество неоптимального кода - будет разницей между моментально работающим сайтом и непрогружающейся долгими секундами страницей.

- Переменная **count** избыточна. То, на что сейчас уходит 3 строки - можно сделать за одну. Поэкспериментируй с операциями с присвоением.
- Проверка `if i in dictionary.keys()` на самом деле тоже лишняя. Из простого - её можно избежать с помощью одного из публичных методов словаря. Попробуй на переменной словаря функцию **dir** чтобы найти его. Более продвинутый способ - уже для профессионалов - через `from collections import defaultdict`.
- `cor[key]` в цикле проходит 3 операции с присвоением. Лучше сделать все преобразования за одно присвоение.

#### Функциональность

- Код вне функций и классов - который исполняется когда запускаешь файл - [принято прятать](https://www.theserverside.com/tip/What-does-the-Python-if-name-equals-main-construct-do#:~:text=Python%27s%20if%20__name__%20%3D%3D%20%27__main__%27%3A%20in%20action) под `if __name__ == '__main__'`. Тестирование кода в основном файле иногда встречается, например с помощью библиотеки **doctest**. Но чтобы избежать лишнего срабатывания при импортах - его тоже принято прятать.

### Что дальше

Примени, пожалуйста, озвученные предложения по улучшению и сдай работу повторно не позже конца недели. Всё как в настоящей работе - правки нормальная практика для серьёзных компаний.

На следующей неделе мы затронем библиотеку `collections` один из словарей которой приятно удивит тебя возможностью сократить твою функцию.
